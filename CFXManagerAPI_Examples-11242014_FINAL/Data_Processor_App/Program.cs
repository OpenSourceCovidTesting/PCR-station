// $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
// $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
// $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
// THIS PROJECT IS NOT A PART OF THE BIORAD API
// THE FOLLOWING CODE READS THE DATA GENERATED BY THE PCR RUN AND CREATES A CONSOLIDATED RESULT FILE IN BOTH CSV AND JSON FORMATS
// The function "processData()" inside class "DataProcessor" is called from 
// TO COMPILE THE FOLLOWING CODE, YOU NEED TO INSTALL "CSVHELPER v15.0.5" AND "NEWTONSOFT.JSON v12.0.3" from NuGET PACKAGE MANAGER
// $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
// $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
// $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.IO;
using System.Data;
using CsvHelper;
using CsvHelper.Configuration;
using CsvHelper.Configuration.Attributes;
using System.Globalization;
using Newtonsoft;
using Newtonsoft.Json;

namespace Data_Processor_App
{
    public class DataPreamble
    {
        public string lab_name, pcr_serial, username, run_date, run_time, plate_barcode, pct_result, nec_result, overall_result;
        public int num_cycles;
        public float setpoint_celsius;

        public DataPreamble()
        {
            lab_name = "Default Lab"; pcr_serial = "Default PCR"; username = "Default User";
            run_date = "Default Date"; run_time = "Default Time"; plate_barcode = "Default Plate Barcode";
            overall_result = "No Result"; pct_result = "No Result"; nec_result = "No Result"; num_cycles = 0;
            setpoint_celsius = 0;
        }
    }

    public class WellData
    {
        public string well_num, well_content, hex_cq, fam_cq, point_of_interest, test_call, well_barcode;
        public float hex_rfu_initial, hex_rfu_3endpoints_avg,
                     fam_rfu_initial, fam_rfu_3endpoints_avg;
        public float[] hex_rfu_points;
        public float[] fam_rfu_points;

        public WellData(int numCycl)
        {
            well_num = "na"; well_content = "na"; hex_cq = "NaN"; fam_cq = "NaN"; point_of_interest = "--";
            test_call = "inconc."; well_barcode = "na"; hex_rfu_initial = 0; hex_rfu_3endpoints_avg = 0;
            fam_rfu_initial = 0; fam_rfu_3endpoints_avg = 0;

            hex_rfu_points = new float[numCycl];
            for (int i = 0; i < numCycl; i++)
                hex_rfu_points[i] = 0;

            fam_rfu_points = new float[numCycl];
            for (int i = 0; i < numCycl; i++)
                fam_rfu_points[i] = 0;
        }
    }

    public class FullTestData
    {
        public DataPreamble data_preamble;
        public List<WellData> wells_data;
    }

    public class DataProcessor
    {
        public void processData(string PCRserial, string outputFileName)
        {
            //string rootFolderPCR = @"C:\Users\Admin\Desktop\results_csvFiles"; //For Release
            //string rootFolderResult = @"C:\Users\Admin\Desktop\Test_Results"; //For Release

            string rootFolderPCR = @"D:\CFXManagerAPI_Examples-11242014_FINAL"; //For testing & simulation
            string rootFolderResult = @"D:\CFXManagerAPI_Examples-11242014_FINAL"; //For testing & simulation

            string jsonResultFileName = string.Format("{0}_{1}_{2}", PCRserial, outputFileName, "Result.txt");
            string jsonResultFilePath = Path.Combine(rootFolderResult, jsonResultFileName);
            string csvResultFileName = string.Format("{0}_{1}_{2}",PCRserial, outputFileName, "Result.csv");
            string csvResultFilePath = Path.Combine(rootFolderResult, csvResultFileName);

            string FAMampl = string.Format("{0} -  {1}", outputFileName,"Quantification Amplification Results_FAM.csv");
            string HEXampl = string.Format("{0} -  {1}", outputFileName, "Quantification Amplification Results_HEX.csv");
            string quantCq = string.Format("{0} -  {1}", outputFileName, "Quantification Cq Results.csv");
            string allelicDiscrim = string.Format("{0} -  {1}", outputFileName, "Allelic Discrimination Results_ADSheet.csv");
            string endpointFAM = string.Format("{0} -  {1}", outputFileName, "End Point Results_FAM.csv");
            string endpointHEX = string.Format("{0} -  {1}", outputFileName, "End Point Results_HEX.csv");
            string meltFAM = string.Format("{0} -  {1}", outputFileName, "Melt Curve Plate View Results_FAM.csv");
            string meltHEX = string.Format("{0} -  {1}", outputFileName, "Melt Curve Plate View Results_HEX.csv");
            string standardCurve = string.Format("{0} -  {1}", outputFileName, "Standard Curve Results.csv");
            string runInfo = string.Format("{0} - {1}", outputFileName, "Run Information.csv");
            string quantPlateFAM = string.Format("{0} -  {1}", outputFileName, "Quantification Plate View Results_FAM.csv");
            string quantPlateHEX = string.Format("{0} -  {1}", outputFileName, "Quantification Plate View Results_HEX.csv");
            string quantSumm = string.Format("{0} -  {1}", outputFileName, "Quantification Summary.csv");
            string ANOVAresults = string.Format("{0} -  {1}", outputFileName, "ANOVA Results_ANOVA.csv");
            string FAMamplPath = Path.Combine(rootFolderPCR, FAMampl);
            string HEXamplPath = Path.Combine(rootFolderPCR, HEXampl);
            string quantCqPath = Path.Combine(rootFolderPCR, quantCq);
            int jj, kk, posCtrlIndx = 10, negCtrlIndx = 0;
            int overallResult = 2, PCTresult = 1, NECresult = 1;
            int numWells, numCycles;
            float tf1, tf2, tf3, CqFAM, rfuFAM;

            DataTable FAMtable = new DataTable();
            DataTable HEXtable = new DataTable();
            DataTable quantCqTable = new DataTable();
            DataTable resultTable = new DataTable();
            DataTable tempTable = new DataTable();
            DataRow emptyRow;

            string[] WELL_CALL = new string[3] { "(-) neg", "(+) POSITIVE", "inconc." };
            string[] PCT_RESULT = new string[2] { "FAIL", "SUCCESS" };
            string[] NEC_RESULT = new string[2] { "FAIL", "SUCCESS" };
            string[] OVERALL_RESULT = new string[3] { "INCONCLUSIVE", "PARTIAL SUCCESS", "SUCCESS" };


            /*//CODE FOR DELETING ANY FILE - STARTS
            try
            {
                if (File.Exists(filePath))
                {
                    Console.WriteLine("File Found. Press any key to Delete it\n");
                    Console.ReadKey(true);
                    File.Delete(filePath);
                    Console.WriteLine("File Deleted\n");
                }
                else
                    Console.WriteLine("File not found!\n");
            }
            catch(IOException ioExp)
            {
                Console.WriteLine(ioExp.Message);
            }
            //CODE FOR DELETING ANY FILE - ENDS*/


            //LOADING THE CQ QUANTIFICATION TABLE - START
            using (var reader = new StreamReader(quantCqPath))
            using (var csv = new CsvReader(reader, CultureInfo.InvariantCulture))
            {
                using (var dr = new CsvDataReader(csv))
                {
                    quantCqTable.Load(dr);
                }
            }
            //LOADING THE CQ QUANTIFICATION TABLE - END


            //CREATING AND LOADING THE FAM TABLE - START
            using (var reader = new StreamReader(FAMamplPath))
            using (var csv = new CsvReader(reader, CultureInfo.InvariantCulture))
            {
                using (var dr = new CsvDataReader(csv))
                {
                    tempTable.Load(dr);
                }
            }

            numWells = tempTable.Columns.Count - 2;
            numCycles = tempTable.Rows.Count;
            FAMtable.Columns.Add("Well Num", typeof(String));
            FAMtable.Columns.Add("Content | FAM RFU -->", typeof(String));

            for (int i = 0; i < numCycles; i++) //
                FAMtable.Columns.Add("Cycle" + (i + 1).ToString(), typeof(String));
            FAMtable.Columns.Add("Well No.", typeof(String));
            FAMtable.Columns.Add("FAM Cq", typeof(String));
            FAMtable.Columns.Add("Set Point Temperature (Celsius)", typeof(String));

            for (int i = 0; i < numWells; i++)
            {
                emptyRow = FAMtable.NewRow();
                for (int j = 0; j < FAMtable.Columns.Count; j++)
                    emptyRow[j] = string.Empty;
                FAMtable.Rows.Add(emptyRow);
            }

            for (int i = 0; i < numWells; i++)
            {
                FAMtable.Rows[i][0] = quantCqTable.Rows[i][1].ToString(); //Well number
                FAMtable.Rows[i][1] = quantCqTable.Rows[i][4].ToString(); //Well content
                FAMtable.Rows[i][numCycles + 2] = quantCqTable.Rows[i][1].ToString(); //Well number again
            }

            jj = 0;
            for (int i = 0; i < quantCqTable.Rows.Count; i++)
            {
                if (quantCqTable.Rows[i][2].ToString() == "FAM")
                {
                    tf1 = Convert.ToSingle(quantCqTable.Rows[i][7].ToString());
                    tf1 = (float)Math.Round(tf1, 2);
                    FAMtable.Rows[jj][numCycles + 3] = tf1.ToString(); //FAM Cq
                    FAMtable.Rows[jj][numCycles + 4] = quantCqTable.Rows[i][14].ToString(); //Set Point tempr
                    ++jj;
                }
            }

            for (int i = 0; i < numWells; i++)
            {
                for (int j = 0; j < numCycles; j++)
                {
                    tf1 = Convert.ToSingle(tempTable.Rows[j][i + 2].ToString());
                    tf1 = (float)Math.Round(tf1, 2);
                    FAMtable.Rows[i][j + 2] = tf1.ToString(); //FAM RFU values
                }
            }
            tempTable.Clear();
            //CREATING AND LOADING THE FAM TABLE - END


            //CREATING AND LOADING THE HEX TABLE - START
            using (var reader = new StreamReader(HEXamplPath))
            using (var csv = new CsvReader(reader, CultureInfo.InvariantCulture))
            {
                using (var dr = new CsvDataReader(csv))
                {
                    tempTable.Load(dr);
                }
            }
            numWells = tempTable.Columns.Count - 2;
            numCycles = tempTable.Rows.Count;
            HEXtable.Columns.Add("Well Num", typeof(String));
            HEXtable.Columns.Add("Content | HEX RFU -->", typeof(String));

            for (int i = 0; i < numCycles; i++)
                HEXtable.Columns.Add("Cycle" + (i + 1).ToString(), typeof(String));
            HEXtable.Columns.Add("Well No.", typeof(String));
            HEXtable.Columns.Add("HEX Cq", typeof(String));
            HEXtable.Columns.Add("Set Point Temperature (Celsius)", typeof(String));

            for (int i = 0; i < numWells; i++)
            {
                emptyRow = HEXtable.NewRow();
                for (int j = 0; j < HEXtable.Columns.Count; j++)
                    emptyRow[j] = string.Empty;
                HEXtable.Rows.Add(emptyRow);
            }

            for (int i = 0; i < numWells; i++)
            {
                HEXtable.Rows[i][0] = quantCqTable.Rows[i][1].ToString(); //Well number
                HEXtable.Rows[i][1] = quantCqTable.Rows[i][4].ToString(); //Well content
                HEXtable.Rows[i][numCycles + 2] = quantCqTable.Rows[i][1].ToString(); //Well number again
            }

            jj = 0;
            for (int i = 0; i < quantCqTable.Rows.Count; i++)
            {
                if (quantCqTable.Rows[i][2].ToString() == "HEX")
                {
                    tf1 = Convert.ToSingle(quantCqTable.Rows[i][7].ToString());
                    tf1 = (float)Math.Round(tf1, 2);
                    HEXtable.Rows[jj][numCycles + 3] = tf1.ToString(); //HEX Cq
                    HEXtable.Rows[jj][numCycles + 4] = quantCqTable.Rows[i][14].ToString(); //Set Point Temperature
                    ++jj;
                }
            }

            for (int i = 0; i < numWells; i++)
            {
                for (int j = 0; j < numCycles; j++)
                {
                    tf1 = Convert.ToSingle(tempTable.Rows[j][i + 2].ToString());
                    tf1 = (float)Math.Round(tf1, 2);
                    HEXtable.Rows[i][j + 2] = tf1.ToString(); //HEX RFU values
                }
            }
            tempTable.Clear();
            //CREATING AND LOADING THE HEX TABLE - END


            //CREATING AND LOADING THE RESULT TABLE - START
            resultTable.Columns.Add("Well_number", typeof(String));
            resultTable.Columns.Add("Well_content", typeof(String));
            resultTable.Columns.Add("HEX_RFU_initial", typeof(String));
            resultTable.Columns.Add("HEX_RFU_3EndPoints_Avg", typeof(String));
            resultTable.Columns.Add("HEX_Cq", typeof(String));
            resultTable.Columns.Add("FAM_RFU_initial", typeof(String));
            resultTable.Columns.Add("FAM_RFU_3EndPoints_Avg", typeof(String));
            resultTable.Columns.Add("FAM_Cq", typeof(String));
            resultTable.Columns.Add("Point_of_interest", typeof(String));
            resultTable.Columns.Add("Call", typeof(String));
            resultTable.Columns.Add("Well_Number", typeof(String));
            resultTable.Columns.Add("Field", typeof(String));
            resultTable.Columns.Add("Field Information", typeof(String));

            for (int i = 1; i <= numWells; i++)
            {
                emptyRow = resultTable.NewRow();
                for (int j = 0; j < resultTable.Columns.Count; j++)
                    emptyRow[j] = "--";
                resultTable.Rows.Add(emptyRow);
            }

            for (int i = 0; i < numWells; i++)
            {
                resultTable.Rows[i][0] = quantCqTable.Rows[i][1].ToString(); //For Well Number
                resultTable.Rows[i][1] = quantCqTable.Rows[i][4].ToString(); //For Well Content
                resultTable.Rows[i][2] = HEXtable.Rows[i][2].ToString(); //For HEX RFU Initial
                tf1 = Convert.ToSingle(HEXtable.Rows[i][numCycles - 1].ToString());
                tf2 = Convert.ToSingle(HEXtable.Rows[i][numCycles].ToString());
                tf3 = Convert.ToSingle(HEXtable.Rows[i][numCycles + 1].ToString());
                resultTable.Rows[i][3] = ((tf1 + tf2 + tf3) / 3).ToString(); //For HEX RFU 3EndPoints-avg
                resultTable.Rows[i][5] = FAMtable.Rows[i][2].ToString(); //For FAM RFU Initial
                tf1 = Convert.ToSingle(FAMtable.Rows[i][numCycles - 1].ToString());
                tf2 = Convert.ToSingle(FAMtable.Rows[i][numCycles].ToString());
                tf3 = Convert.ToSingle(FAMtable.Rows[i][numCycles + 1].ToString());
                resultTable.Rows[i][6] = ((tf1 + tf2 + tf3) / 3).ToString(); //For FAM RFU 3EndPoints-avg
                resultTable.Rows[i][10] = quantCqTable.Rows[i][1].ToString(); //For Well Number again

            }

            jj = 0; kk = 0;
            for (int i = 0; i < quantCqTable.Rows.Count; i++)
            {
                if (quantCqTable.Rows[i][2].ToString() == "FAM")
                {
                    tf1 = Convert.ToSingle(quantCqTable.Rows[i][7].ToString());
                    tf1 = (float)Math.Round(tf1, 2);
                    resultTable.Rows[jj][7] = tf1.ToString(); //For FAM Cq
                    ++jj;
                }
                if (quantCqTable.Rows[i][2].ToString() == "HEX")
                {
                    tf1 = Convert.ToSingle(quantCqTable.Rows[i][7].ToString());
                    tf1 = (float)Math.Round(tf1, 2);
                    resultTable.Rows[kk][4] = tf1.ToString(); //For HEX Cq
                    ++kk;
                }
            }

            for (int i = 0; i < numWells; i++) // Loop for flagging critical wells
            {
                resultTable.Rows[i][8] = "--"; //By default, there is no flag

                if (resultTable.Rows[i][1].ToString() == "Pos Ctrl" || resultTable.Rows[i][1].ToString() == "Neg Ctrl")
                {   //POSITIVE AND NEGATIVE CONTROL WELLS ARE ALWAYS FLAGGED
                    resultTable.Rows[i][8] = "<<CHECK!!";
                    if (resultTable.Rows[i][1].ToString() == "Pos Ctrl")
                        posCtrlIndx = i;
                    else
                        negCtrlIndx = i;
                }
                else
                {
                    if (resultTable.Rows[i][7].ToString() != "NaN")
                    {
                        CqFAM = Convert.ToSingle(resultTable.Rows[i][7].ToString());
                        rfuFAM = Convert.ToSingle(resultTable.Rows[i][6].ToString());
                        if (CqFAM >= 15 && rfuFAM >= 500) // Flag thresholds defined here
                            resultTable.Rows[i][8] = "<<CHECK!!";
                    }
                }
            }

            for (int i = 0; i < numWells; i++) //Loop for making the positive/negative call
            {
                resultTable.Rows[i][9] = WELL_CALL[2]; //By default, the test is INCONCLUSIVE
                if (resultTable.Rows[i][7].ToString() == "NaN")
                {
                    if (resultTable.Rows[i][4].ToString() != "NaN")
                        resultTable.Rows[i][9] = WELL_CALL[0];
                }
                else
                {
                    CqFAM = Convert.ToSingle(resultTable.Rows[i][7].ToString());
                    rfuFAM = Convert.ToSingle(resultTable.Rows[i][6].ToString());
                    if (CqFAM >= 19.9 && rfuFAM >= 1000) // Call thresholds defined here
                        resultTable.Rows[i][9] = WELL_CALL[1];
                    else
                        resultTable.Rows[i][9] = WELL_CALL[0];
                }
            }

            resultTable.Rows[0][11] = "Lab Name";
            resultTable.Rows[1][11] = "PCR Serial num";
            resultTable.Rows[2][11] = "Username";
            resultTable.Rows[3][11] = "Date of Run";
            resultTable.Rows[4][11] = "Time of Run";
            resultTable.Rows[5][11] = "microPlate Bar Code";
            resultTable.Rows[6][11] = "Number of Cycles";
            resultTable.Rows[7][11] = "Set Point (Celsius)";
            resultTable.Rows[8][11] = "PCT result";
            resultTable.Rows[9][11] = "NEC result";
            resultTable.Rows[10][11] = "Overall Test Result";
            resultTable.Rows[6][12] = numCycles.ToString();
            resultTable.Rows[7][12] = quantCqTable.Rows[0][14]; // Set point temperature (Celsius)

            overallResult = 2;
            if (resultTable.Rows[posCtrlIndx][9].ToString() == WELL_CALL[1])
            { PCTresult = 1; resultTable.Rows[8][12] = PCT_RESULT[1]; }
            else
            {
                PCTresult = 0;
                resultTable.Rows[8][12] = PCT_RESULT[0];
                for (int i = 0; i < numWells; i++)
                {
                    if (i != posCtrlIndx && i != negCtrlIndx)
                        resultTable.Rows[i][9] = WELL_CALL[2];
                }
                overallResult = 0;
            }

            if (resultTable.Rows[negCtrlIndx][9].ToString() == WELL_CALL[0])
            { NECresult = 1; resultTable.Rows[9][12] = NEC_RESULT[1]; }
            else
            {
                NECresult = 0;
                resultTable.Rows[9][12] = NEC_RESULT[0];
                for (int i = 0; i < numWells; i++)
                {
                    if (i != posCtrlIndx && i != negCtrlIndx)
                        resultTable.Rows[i][9] = WELL_CALL[2];
                }
                overallResult = 0;
            }

            if (overallResult != 0)
            {
                for (int i = 0; i < numWells; i++)
                {
                    if (resultTable.Rows[i][9].ToString() == WELL_CALL[2])
                    {
                        overallResult = 1;
                        break;
                    }
                }
            }

            resultTable.Rows[10][12] = OVERALL_RESULT[overallResult];
            //CREATING AND LOADING THE RESULT TABLE - END


            //WRITING THE TABLES INTO CSV FILES - START
            using (var textWriter = File.CreateText(csvResultFilePath)) // Writing the result file
            {
                using (var csv = new CsvWriter(textWriter, CultureInfo.InvariantCulture))
                {
                    // Write columns
                    foreach (DataColumn column in resultTable.Columns)
                    {
                        csv.WriteField(column.ColumnName);
                    }
                    csv.NextRecord();

                    // Write row values
                    foreach (DataRow row in resultTable.Rows)
                    {
                        for (var i = 0; i < resultTable.Columns.Count; i++)
                        {
                            csv.WriteField(row[i]);
                        }
                        csv.NextRecord();
                    }
                }
            }

            /*using (var textWriter = File.CreateText(@"D:\CFXManagerAPI_Examples-11242014_FINAL\FAMtable.csv")) // Writing the FAMtable
            {
                using (var csv = new CsvWriter(textWriter, CultureInfo.InvariantCulture))
                {
                    // Write columns
                    foreach (DataColumn column in FAMtable.Columns)
                    {
                        csv.WriteField(column.ColumnName);
                    }
                    csv.NextRecord();

                    // Write row values
                    foreach (DataRow row in FAMtable.Rows)
                    {
                        for (var i = 0; i < FAMtable.Columns.Count; i++)
                        {
                            csv.WriteField(row[i]);
                        }
                        csv.NextRecord();
                    }
                }
            }*/

            /*using (var textWriter = File.CreateText(@"D:\CFXManagerAPI_Examples-11242014_FINAL\HEXtable.csv")) // Writing the HEXtable
            {
                using (var csv = new CsvWriter(textWriter, CultureInfo.InvariantCulture))
                {
                    // Write columns
                    foreach (DataColumn column in HEXtable.Columns)
                    {
                        csv.WriteField(column.ColumnName);
                    }
                    csv.NextRecord();

                    // Write row values
                    foreach (DataRow row in HEXtable.Rows)
                    {
                        for (var i = 0; i < HEXtable.Columns.Count; i++)
                        {
                            csv.WriteField(row[i]);
                        }
                        csv.NextRecord();
                    }
                }
            }*/
            //WRITING THE TABLES INTO CSV FILES - END


            //WRITING THE RESULT FILE TO OBJECTS - START
            DataPreamble preamble = new DataPreamble();
            List<WellData> wells = new List<WellData>();
            FullTestData compact_data = new FullTestData();
            string jsonText;

            preamble.lab_name = "Calcinate Lab"; preamble.pcr_serial = PCRserial; preamble.username = "User";
            preamble.run_date = outputFileName.Substring(5,10); preamble.run_time = outputFileName.Substring(16,8);
            preamble.plate_barcode = "BARCODE";
            preamble.num_cycles = numCycles; preamble.setpoint_celsius = Convert.ToSingle(resultTable.Rows[7][12]);
            preamble.pct_result = PCT_RESULT[PCTresult]; preamble.nec_result = NEC_RESULT[NECresult];
            preamble.overall_result = OVERALL_RESULT[overallResult];

            for (int i = 0; i < numWells; i++)
                wells.Add(new WellData(numCycles));
            jj = 0;
            foreach (WellData well in wells)
            {
                well.well_num = resultTable.Rows[jj][0].ToString();
                well.well_content = resultTable.Rows[jj][1].ToString();
                well.hex_rfu_initial = Convert.ToSingle(resultTable.Rows[jj][2]);
                well.hex_rfu_3endpoints_avg = Convert.ToSingle(resultTable.Rows[jj][3]);
                well.hex_cq = resultTable.Rows[jj][4].ToString();
                well.fam_rfu_initial = Convert.ToSingle(resultTable.Rows[jj][5]);
                well.fam_rfu_3endpoints_avg = Convert.ToSingle(resultTable.Rows[jj][6]);
                well.fam_cq = resultTable.Rows[jj][7].ToString();
                well.point_of_interest = resultTable.Rows[jj][8].ToString();
                well.test_call = resultTable.Rows[jj][9].ToString();
                well.well_barcode = resultTable.Rows[jj][11].ToString();

                for (int i = 0; i < numCycles; i++)
                {
                    well.hex_rfu_points[i] = Convert.ToSingle(HEXtable.Rows[jj][i + 2]);
                    well.fam_rfu_points[i] = Convert.ToSingle(FAMtable.Rows[jj][i + 2]);
                }

                ++jj;
            }

            compact_data.data_preamble = preamble;
            compact_data.wells_data = wells;
            // WRITING THE RESULT FILES TO OBJECTS - END

            // SERIALIZING THE OBJECTS TO JSON AND WRITING THE TXT FILE - START
            jsonText = JsonConvert.SerializeObject(compact_data, Formatting.Indented);
            File.WriteAllText(jsonResultFilePath, jsonText, Encoding.UTF8);
            // SERIALIZING THE OBJECTS TO JSON AND WRITING THE TXT FILE - END


            // DELETING THE PCR FILES AND DATATABLES - START
            if (File.Exists(quantCqPath))
                File.Delete(quantCqPath);
            if (File.Exists(FAMamplPath))
                File.Delete(FAMamplPath);
            if (File.Exists(HEXamplPath))
                File.Delete(HEXamplPath);
            if (File.Exists(Path.Combine(rootFolderPCR, allelicDiscrim)))
                File.Delete(Path.Combine(rootFolderPCR, allelicDiscrim));
            if (File.Exists(Path.Combine(rootFolderPCR, meltFAM)))
                File.Delete(Path.Combine(rootFolderPCR, meltFAM));
            if (File.Exists(Path.Combine(rootFolderPCR, meltHEX)))
                File.Delete(Path.Combine(rootFolderPCR, meltHEX));
            //if (File.Exists(Path.Combine(rootFolderPCR, endpointFAM)))
            //    File.Delete(Path.Combine(rootFolderPCR, endpointFAM));
            if (File.Exists(Path.Combine(rootFolderPCR, endpointHEX)))
                File.Delete(Path.Combine(rootFolderPCR, endpointHEX));
            if (File.Exists(Path.Combine(rootFolderPCR, standardCurve)))
                File.Delete(Path.Combine(rootFolderPCR, standardCurve));
            if (File.Exists(Path.Combine(rootFolderPCR, runInfo)))
                File.Delete(Path.Combine(rootFolderPCR, runInfo));
            if (File.Exists(Path.Combine(rootFolderPCR, quantPlateFAM)))
                File.Delete(Path.Combine(rootFolderPCR, quantPlateFAM));
            if (File.Exists(Path.Combine(rootFolderPCR, quantPlateHEX)))
                File.Delete(Path.Combine(rootFolderPCR, quantPlateHEX));
            if (File.Exists(Path.Combine(rootFolderPCR, quantSumm)))
                File.Delete(Path.Combine(rootFolderPCR, quantSumm));
            if (File.Exists(Path.Combine(rootFolderPCR, ANOVAresults)))
                File.Delete(Path.Combine(rootFolderPCR, ANOVAresults));
            HEXtable.Clear();
            FAMtable.Clear();
            resultTable.Clear();
            //DELETING THE PCR FILES AND DATATABLES - END
        }
    }

    class Program
    {
        public static void Main()
        {

        }
    }
}
